# 摄像头自动检测和跟踪方案

## 📋 需求
实现自动检测和跟踪新增加的video设备，无需手动修改配置。

---

## 🎯 方案对比

### 方案1: 自动检测 + Fallback机制 (推荐)
**优点**:
- 最小改动，只修改`util.py`中的`get_camera_config()`函数
- 自动检测可用设备，如果配置的设备不可用，自动fallback到第一个可用设备
- 向后兼容，如果环境变量已设置，优先使用环境变量

**实现方式**:
- 在`get_camera_config()`中集成`detect_cameras.py`的检测逻辑
- 如果配置的设备不存在或不可用，自动选择第一个可用设备
- 记录日志，方便调试

**需要修改的文件**:
- `teleop/util.py` - 增强`get_camera_config()`函数

---

### 方案2: 动态设备映射 (Docker Compose)
**优点**:
- 在Docker层面自动映射所有video设备
- 不需要修改代码

**缺点**:
- 需要修改`docker-compose.yml`
- 可能映射不需要的设备

**实现方式**:
```yaml
devices:
  - "/dev/video0:/dev/video0"
  - "/dev/video1:/dev/video1"
  - "/dev/video2:/dev/video2"
  - "/dev/video3:/dev/video3"
  - "/dev/video4:/dev/video4"
  - "/dev/video5:/dev/video5"
  # 或者使用通配符（如果Docker支持）
```

**需要修改的文件**:
- `teleop/docker-compose.yml` - 添加更多设备映射

---

### 方案3: 启动时自动检测脚本
**优点**:
- 不修改核心代码
- 在启动前自动检测并设置环境变量

**缺点**:
- 需要额外的启动脚本
- 每次启动都需要检测

**实现方式**:
- 创建启动脚本，在运行`gstreamer_webrtc.py`前检测摄像头
- 自动设置环境变量或更新配置文件

**需要创建的文件**:
- `teleop/auto_detect_camera.sh` - 自动检测脚本

---

### 方案4: 运行时动态检测 (最灵活)
**优点**:
- 运行时动态检测，支持热插拔
- 可以定期检查设备变化

**缺点**:
- 需要修改核心代码逻辑
- 可能影响性能

**实现方式**:
- 在`gstreamer_webrtc.py`启动时检测设备
- 如果设备不可用，自动重新检测并切换

**需要修改的文件**:
- `teleop/util.py` - 添加动态检测函数
- `teleop/gstreamer_webrtc.py` - 添加设备检测和重连逻辑

---

## 🚀 推荐实现：方案1 (自动检测 + Fallback)

### 实现细节

#### 1. 增强`util.py`中的`get_camera_config()`函数

添加自动检测逻辑：
- 如果`CAMERA_PRIMARY_DEVICE`环境变量未设置或设备不可用
- 自动调用检测函数，找到第一个可用设备
- 记录日志，方便调试

#### 2. 创建设备检测辅助函数

在`util.py`中添加：
```python
def detect_working_cameras():
    """检测所有可用的摄像头设备"""
    # 使用detect_cameras.py中的逻辑
    # 返回可用设备列表
```

#### 3. 修改`get_camera_config()`函数

```python
def get_camera_config():
    """Get camera configuration with auto-detection fallback."""
    config = {}
    
    # 检测可用设备
    working_devices = detect_working_cameras()
    
    # 获取主设备
    primary_from_env = os.getenv('CAMERA_PRIMARY_DEVICE')
    if primary_from_env and primary_from_env in working_devices:
        config['primary_device'] = primary_from_env
        logger.info(f"Using configured primary device: {primary_from_env}")
    elif working_devices:
        config['primary_device'] = working_devices[0]
        logger.warning(f"Configured device {primary_from_env} not available, using auto-detected: {working_devices[0]}")
    else:
        config['primary_device'] = CAMERA_DEFAULTS['primary_device']
        logger.error(f"No working cameras detected, using default: {CAMERA_DEFAULTS['primary_device']}")
    
    # 类似处理secondary_device...
```

---

## 📝 具体实现代码

### 方案1实现 (需要你的允许才能修改)

我会创建一个增强版的`util.py`，添加自动检测功能，但保持向后兼容。

**修改内容**:
1. 在`util.py`中添加`detect_working_cameras()`函数
2. 修改`get_camera_config()`函数，添加自动检测逻辑
3. 保持所有现有功能不变

**优点**:
- ✅ 向后兼容 - 如果环境变量已设置且设备可用，优先使用
- ✅ 自动fallback - 如果配置的设备不可用，自动选择可用设备
- ✅ 日志记录 - 记录检测和选择过程，方便调试
- ✅ 最小改动 - 只修改一个文件

---

## 🔧 Docker Compose增强 (方案2补充)

如果需要支持更多设备，可以修改`docker-compose.yml`:

```yaml
devices:
  - "/dev/video0:/dev/video0"
  - "/dev/video1:/dev/video1"
  - "/dev/video2:/dev/video2"
  - "/dev/video3:/dev/video3"
  - "/dev/video4:/dev/video4"
  - "/dev/video5:/dev/video5"
```

这样容器内就能访问所有video设备，代码可以自动选择可用的。

---

## 🎯 推荐组合方案

**最佳实践**: 方案1 + 方案2的组合

1. **Docker层面**: 映射所有可能的video设备 (方案2)
2. **代码层面**: 自动检测和fallback (方案1)

这样：
- 新设备插入后，Docker自动映射
- 代码自动检测并使用可用设备
- 无需手动修改配置

---

## ⚠️ 注意事项

1. **设备权限**: 确保所有video设备有正确的权限
2. **设备稳定性**: 自动检测可能选择不稳定的设备，建议优先使用环境变量指定
3. **性能影响**: 检测过程需要时间，建议在启动时检测一次，而不是运行时频繁检测

---

## 📊 方案选择建议

| 方案 | 改动程度 | 灵活性 | 推荐度 |
|------|---------|--------|--------|
| 方案1 | 小 | 高 | ⭐⭐⭐⭐⭐ |
| 方案2 | 小 | 中 | ⭐⭐⭐⭐ |
| 方案3 | 中 | 中 | ⭐⭐⭐ |
| 方案4 | 大 | 很高 | ⭐⭐ |

**推荐**: 方案1 + 方案2的组合

